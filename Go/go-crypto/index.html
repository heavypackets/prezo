<!DOCTYPE html>
<html>
  <head>
    <title>Go Crypto</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://cdn.jsdelivr.net/gh/tonsky/FiraCode@1.207/distr/fira_code.css);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Fira Code', monospace; }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Go Crypto By Example
## Code and anecdote

### Sabree Blackmon
Senior Security Engineer @Docker

@HeavyPackets

---
class: middle

# Agenda
- Landscape Overview 
- Random Numbers Generators
- Hashing
- X509
- TLS (TL;DR)
- Javascript Web Tokens (JWT)

---
class: center, middle

# Housekeeping

---
class: center, middle

# Don't implement your own crypto algorithms
## _(please)_

---
class: center, middle

# Don't implement your own protocols
But if you absolutely need to, work with folks who have crypto expertise

???

There are legitimate scenarios where you may need to design your own proto (service authentication, for instance)

---
class: center, middle

# This talk is not technical guidance
If you break or leak something, it isn't my fault

---
class: center, middle

# Ask Questions!
Interrupt if there are things you do not grok. You are never the only one who doesn't

---
class: center, middle

# Let's get started

---
class: center, middle

# Go's Crypto Landscape
## It's really good...
--
 _but be diligent_

???
Not much more to say here. The Go standard library, as we'll see, has a huge amount of functionality built-in, although some of it is experimental. Which leads to...

Please, do your due-dillegence when searching out crypto libraries to use. Who are it's contributors? Has it been reviewed? How many stars does it have on GitHub?

---
class: center, middle

# Go's Crypto Landscape
## Is it production ready?
--
 _mostly yes._

---
class: center, middle

## Go is fast -- and so are it's crypto implementations.
### But! Go routines are nondeterministic.


???

Whether this last point matters to you will depend. What is does mean if you are implementing new protocols, you must use appropriate locking constructs, etc.

---
class: center, middle

# Now, Examples

---
class: center, middle

# Random Number Generators

???

So, random numbers are useful for a large number of crypto use-cases. They're simple, so lets go there first

---
```go
package main

import "time"
import "fmt"
import "math/rand"

func main() {
    source := rand.NewSource(time.Now().UnixNano())
    r := rand.New(source)
    fmt.Print(r.Intn(500))
}
```
--

Does anyone see anything wrong with this?

--

The "math/rand" package produces _pseudorandom_ numbers. The numbers generated are a constant function with the given seed.

--

This is not suitable for crypto purposes. Why?


???
Let's start with a quick example of generating random numbers using the time as a seed. 

If you need random numbers for crypto purposes, this is not acceptible

---
class: center, middle

## Let's use crypto/rand instead to generate some random data

---
```go
package main

import (
    "fmt"
    "crypto/rand"
    "encoding/base64"
)

func main() {
    randomBytes := make([]byte, 32)
    _, err := rand.Read(randomBytes)

    if err != nil {
        panic(err)
    }

    token := base64.StdEncoding.EncodeToString(randomBytes)

    fmt.Println(token)
}
```
[Better](https://play.golang.org/p/6UO6d6mKA5d) -- crypto/rand uses OS specific RNG for it's source of data. Encoding the binary in Base64 provides simple normalization to ASCII.

--

This makes it suitable for creating tokens, nonces, etc.

---
class: center, middle

# Hashing Methods
## What and why?

???

Next lets go into hashing algorithms
---
class: center, middle

## A hashing function is a function that produces a constant, fixed-sized output, given some variable-sized input.

---
class: center, middle

## Hashing functions suitable for security use-cases are difficult to reverse
Meaning given any output, it is extremely complex to calculate what was used as input!

---
class: center, middle

## Hashing functions are constant!
Meaning any given input will produce the same output everytime.

--

This property makes hashing functions particularly useful for storing passwords or pins -- we can strictly compare our stored hash with a hash generated by user input.

???

Does this make sense?

---
class: center, middle

## But! Hashing functions are constant!
This means we need to _salt_ the input with some bit of randomness so that people can't build dictionaries of hashed words.

--

_These are called rainbow tables_

---
class: center, middle

background-image: url(rbt.png)

???

Does this make sense

---
class: center, middle

# Let's talk about Bcrypt

---
## bcrypt is a popular hashing function for a few reasons:

--
 
- You can adjust the number iterations to tune complexity as hardware gets powerful

--

- You can choose tune for memory or processing complexity

--

- Hashes are salted automatically

--

- There's a standard encoding of the hash that carries all of the options used to create the hash -- so they are portable

---
class: center, middle

# How does this work in Go?
--

[https://play.golang.org/p/VEhBAcVMTBK]

_Note:_ The Go Playground does not support true random number generation, so multiple runs of bcrypt hashing will result in identical hashes. Run locally for proper demo.

---
class: center, middle

# X509 Public-Key Encryption

---

## What makes public-key encryption different?
--

- The keys are asymmetric -- meaning seperate keys are used for both encryption and decryption

--

- The public key is used for encrypting data

--

- The private key is used to decrypt data

--

- Therefore, anyone can send you secrets that only _you_ can decrypt

---

## What makes X509 special? (Abridged)

--

- X.509 is a standard for public-key certificates

--

- X.509 is used for SSL/TLS and subsequently HTTPS, FTPS, SSH, etc

--

- X.509 certificates contain an _identity_ -- usually an person/organization and/or hostname

---
## What makes X509 special? (Abridged)


- X.509 certificates can be _signed_ by a _certificate authority (CA)_ that acts as a root of trust 

--

- The certificate signature establishes that the identity claimed in the certificate has been validated by the CA

--

- Therefore, the X.509 private key can be used to _attest_ oneself to the identity ascribed in the certicate

--

???

This is a lot -- but in affect, if you trust the CA, and the certificate has been signed by the CA, you should be able to trust the certicate.

Your browser already trusts certificates signed by a handleful of public CAs

---
class: center, middle

## What makes X509 special?

--

## It's basically the [internet](https://play.golang.org/p/fsDcDtXTdXB) (sort of)

![](mim.png)
[Credit](https://www.usna.edu/Users/cs/wcbrown/courses/si110AY13S/lec/l28/lec.html)

???

If you are really interested in the nitty gritty I would highly recommend researching more

---
class: center, middle

# TLS TL;DR

---
class: center, middle

## TLS (Transport Layer Security) is the _modern_ transport protocol underneath HTTPS

--

SSL is still used in places but we are steadfastly moving away from that


--

The TLS protocol describes how we can establish trust between two unknown parties using X.509 certificates through a process called a _handshake_

---
class: center, middle

![TLS](tls.png)
[Credit](https://medium.com/@vanrijn/what-is-new-with-tls-1-3-e991df2caaac)

---
class: center, middle

## What does this have to do with Go?
--

Go is becoming a first-class choice for developing backend web & infrastructure services.

---
class: center, middle

## What does this have to do with Go?

These services need to be able to communicate securely and establish trust amongst themselves.

---
class: center, middle

## What does this have to do with Go?

They can do this by communicating over TLS established by X.509 certificates and shared roots of trust (CA).

???

X.509 certicates are *the* way for establishing TLS connections. Because X.509 certicates are based on a root of trust model, if I can validate the public key you are presenting, and I can establish a secure connection.

---
class: center, middle

# What does this look like in practice?

---
## First, as a server
```go
package main

import "crypto/tls"

func main() {
    // What certificates we present
	certPem := []byte(`... public key`)
    keyPem := []byte(`...private key`)
	cert, _ := tls.X509KeyPair(certPem, keyPem)

	cfg := &tls.Config{Certificates: []tls.Certificate{cert}}
	listener, _ := tls.Listen("tcp", "localhost:2000", cfg)
    
    ....
}
```
If we don't specific RootCAs in the tls.Config, it'll use the certificate bundle on the host machine.

???
So, establishing TLS in Go is actually extremely easy. 
---
## Second, as a client
```go
package main

import "crypto/tls"

func main() {
    conf := &tls.Config{}

    conn, _ := tls.Dial("tcp", "localhost:2000", conf)
    defer conn.Close()

    n, _ := conn.Write([]byte("hello\n"))

    buf := make([]byte, 100)
    n, _ = conn.Read(buf)
    ...
}
```

---
class: center, middle

## Pretty simple!
--

Establishing TLS connections on Go is simple. HTTPS connections are equally simple and most major Go web frameworks support tls.Config to configure HTTPS.

---
class: center, middle

## But!

--

TLS connections can also be easily misconfigured. Please reference the full documentation at crypto/tls.

---
class: center, middle

# Javascript Web Tokens (JWT)

---

## What isn't a JWT?

--

- Encryption.

--

- A secret. The data they contain is not encrypted in transit.

--

- Javascript specific

--

- Magic

---

## What is a JWT?

--

"A token [JWT] is simply a JSON object that is signed by its author. This tells you exactly two things about the data:


- The author of the token was in the possession of the signing secret


- The data has not been modified since it was signed"



[Source](https://github.com/dgrijalva/jwt-go)

---

## What can we do with them?

--

- Stick them in client-side cookies 

--

- Stick them in HTTP headers to be read by proxies, load balancers, etc

--

- Use them for short-lived session tokens

--

- Use them for client/server authentication

---

## JWT's contain a number of standard _claims_, or standard fields in the JSON object
```go
type StandardClaims struct {
    Audience  string `json:"aud,omitempty"`
    ExpiresAt int64  `json:"exp,omitempty"`
    Id        string `json:"jti,omitempty"`
    IssuedAt  int64  `json:"iat,omitempty"`
    Issuer    string `json:"iss,omitempty"`
    NotBefore int64  `json:"nbf,omitempty"`
    Subject   string `json:"sub,omitempty"`
}
```

--

Of note, JWTs can have expiration but are also extremely small. This makes them perfect for short-level purposes where bandwidwth is an issue.

---

class: center, middle

## JWT's are then encoded for easier transport
### You can use [standard decoding tools](https://jwt.io) to see the contents of the JWT

---

class: center, middle

## JWTs can be signed with a symmetric key [(like HMAC)](https://godoc.org/github.com/dgrijalva/jwt-go#SigningMethodHMAC) or an [asymmetric key](https://blog.usejournal.com/symmetric-vs-asymmetric-jwts-bd5d1a9567f6)

--

With symmetric signing, the recieving & sending party share the same secret that is used to decrypt the signature (to validate the JWT) and to sign a new JWT.

--

This makes them flexible for a variety of cases and trust bounderies

---

class: center, middle

## How do we use them in Go?
### Using grijalva/jwt-go

---

class: center, middle

## [Signing a JWT (symmetric)](https://play.golang.org/p/9sP4RuSzuoR)

---

class: center, middle

## [Verifying a JWT (symmetric)](https://play.golang.org/p/b5piKjk8fLP)

---

class: center, middle

# That's all folks (for now)


    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create();
    </script>
  </body>
</html>

<!--

## [Verifying a JWT (symmetric)]

???

eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1MDAwLCJpc3MiOiJ0ZXN0In0.X0baNOfkHhy0Fg19FQhoSwbJdR9qtPeLgqcm-D3X38g -->